package cabbageroll.notrisdefect.core.tables;

import cabbageroll.notrisdefect.core.GameLogic;
import cabbageroll.notrisdefect.core.Point;

public class KickTable {
    public static final KickTable SRS_PLUS = new KickTable(new int[][][][]{
        {//J, L, S, T, Z Tetromino Wall Kick Data
            {{0, 0}, {-1, 0}, {-1, +1}, {0, -2}, {-1, -2}},
            {{0, 0}, {+1, 0}, {+1, -1}, {0, +2}, {+1, +2}},

            {{0, 0}, {+1, 0}, {+1, -1}, {0, +2}, {+1, +2}},
            {{0, 0}, {-1, 0}, {-1, +1}, {0, -2}, {-1, -2}},

            {{0, 0}, {+1, 0}, {+1, +1}, {0, -2}, {+1, -2}},
            {{0, 0}, {-1, 0}, {-1, -1}, {0, +2}, {-1, +2}},

            {{0, 0}, {-1, 0}, {-1, -1}, {0, +2}, {-1, +2}},
            {{0, 0}, {+1, 0}, {+1, +1}, {0, -2}, {+1, -2}},

            {{0, 0}, {0, +1}, {+1, +1}, {-1, +1}, {+1, 0}, {-1, 0}},
            {{0, 0}, {0, -1}, {-1, -1}, {+1, -1}, {-1, 0}, {+1, 0}},

            {{0, 0}, {+1, 0}, {+1, +2}, {+1, +1}, {0, +2}, {0, +1}},
            {{0, 0}, {-1, 0}, {-1, +2}, {-1, +1}, {0, +2}, {0, +1}},
        },
        {//I Tetromino Wall Kick Data
            {{0, 0}, {+1, 0}, {-2, 0}, {-2, -1}, {+1, +2}},
            {{0, 0}, {-1, 0}, {+2, 0}, {-1, -2}, {+2, +1}},

            {{0, 0}, {-1, 0}, {+2, 0}, {-1, +2}, {+2, -1}},
            {{0, 0}, {-2, 0}, {+1, 0}, {-2, +1}, {+1, -2}},

            {{0, 0}, {+2, 0}, {-1, 0}, {+2, +1}, {-1, -2}},
            {{0, 0}, {+1, 0}, {-2, 0}, {+1, +2}, {-2, -1}},

            {{0, 0}, {+1, 0}, {-2, 0}, {+1, -2}, {-2, +1}},
            {{0, 0}, {-1, 0}, {+2, 0}, {+2, -1}, {-1, +2}},

            {{0, 0}, {0, +1}},
            {{0, 0}, {0, -1}},

            {{0, 0}, {+1, 0}},
            {{0, 0}, {-1, 0}}
        }
    });
    public static final KickTable SRS = new KickTable(new int[][][][]{
        {//J, L, S, T, Z Tetromino Wall Kick Data
            {{0, 0}, {-1, 0}, {-1, +1}, {0, -2}, {-1, -2}},
            {{0, 0}, {+1, 0}, {+1, -1}, {0, +2}, {+1, +2}},

            {{0, 0}, {+1, 0}, {+1, -1}, {0, +2}, {+1, +2}},
            {{0, 0}, {-1, 0}, {-1, +1}, {0, -2}, {-1, -2}},

            {{0, 0}, {+1, 0}, {+1, +1}, {0, -2}, {+1, -2}},
            {{0, 0}, {-1, 0}, {-1, -1}, {0, +2}, {-1, +2}},

            {{0, 0}, {-1, 0}, {-1, -1}, {0, +2}, {-1, +2}},
            {{0, 0}, {+1, 0}, {+1, +1}, {0, -2}, {+1, -2}},

            {},
            {},

            {},
            {},
        },
        {//I Tetromino Wall Kick Data
            {{0, 0}, {-2, 0}, {+1, 0}, {-2, -1}, {+1, +2}},
            {{0, 0}, {+2, 0}, {-1, 0}, {+2, +1}, {-1, -2}},

            {{0, 0}, {-1, 0}, {+2, 0}, {-1, +2}, {+2, -1}},
            {{0, 0}, {+1, 0}, {-2, 0}, {+1, -2}, {-2, +1}},

            {{0, 0}, {+2, 0}, {-1, 0}, {+2, +1}, {-1, -2}},
            {{0, 0}, {-2, 0}, {+1, 0}, {-2, -1}, {+1, +2}},

            {{0, 0}, {+1, 0}, {-2, 0}, {+1, -2}, {-2, +1}},
            {{0, 0}, {-1, 0}, {+2, 0}, {-1, +2}, {+2, -1}},

            {},
            {},

            {},
            {},
        }
    });
    public static final KickTable SRS_180 = new KickTable(new int[][][][]{
        {//J, L, S, T, Z Tetromino Wall Kick Data
            {{0, 0}, {-1, 0}, {-1, +1}, {0, -2}, {-1, -2}},
            {{0, 0}, {+1, 0}, {+1, -1}, {0, +2}, {+1, +2}},

            {{0, 0}, {+1, 0}, {+1, -1}, {0, +2}, {+1, +2}},
            {{0, 0}, {-1, 0}, {-1, +1}, {0, -2}, {-1, -2}},

            {{0, 0}, {+1, 0}, {+1, +1}, {0, -2}, {+1, -2}},
            {{0, 0}, {-1, 0}, {-1, -1}, {0, +2}, {-1, +2}},

            {{0, 0}, {-1, 0}, {-1, -1}, {0, +2}, {-1, +2}},
            {{0, 0}, {+1, 0}, {+1, +1}, {0, -2}, {+1, -2}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},
        },
        {//I Tetromino Wall Kick Data
            {{0, 0}, {-2, 0}, {+1, 0}, {-2, -1}, {+1, +2}},
            {{0, 0}, {+2, 0}, {-1, 0}, {+2, +1}, {-1, -2}},

            {{0, 0}, {-1, 0}, {+2, 0}, {-1, +2}, {+2, -1}},
            {{0, 0}, {+1, 0}, {-2, 0}, {+1, -2}, {-2, +1}},

            {{0, 0}, {+2, 0}, {-1, 0}, {+2, +1}, {-1, -2}},
            {{0, 0}, {-2, 0}, {+1, 0}, {-2, -1}, {+1, +2}},

            {{0, 0}, {+1, 0}, {-2, 0}, {+1, -2}, {-2, +1}},
            {{0, 0}, {-1, 0}, {+2, 0}, {-1, +2}, {+2, -1}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},
        }
    });
    public static final KickTable LUMINES = new KickTable(new int[][][][]{
        {//J, L, S, T, Z Tetromino Wall Kick Data
            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},
        },
        {//I Tetromino Wall Kick Data
            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},

            {{0, 0}},
            {{0, 0}},
        }
    });

    /*
    Order:
    0R,R0,R2,2R,2L,L2,L0,0L
    02,20,RL,LR
    To disable specific rotation (most commonly 180 rotations),
    don't put any tests and the rotation will fail (compare srs_guideline and srs_guideline_180).
    */
    private final Point[][][] kicks;

    public KickTable(int[][][][] kicks) {
        // shit
        this.kicks = new Point[2][12][];
        for (int i = 0; i < kicks.length; i++) {
            int[][][] type = kicks[i];
            for (int j = 0; j < type.length; j++) {
                int[][] row = type[j];
                this.kicks[i][j] = new Point[row.length];
                for (int k = 0; k < row.length; k++) {
                    int[] offset = row[k];
                    this.kicks[i][j][k] = new Point(offset[0], offset[1]);
                }
            }
        }
    }

    public int getX(int piece, int state, int tries) {
        return kicks[piece == GameLogic.PIECE_I ? 1 : 0][state][tries].x;
    }

    public int getY(int piece, int state, int tries) {
        return kicks[piece == GameLogic.PIECE_I ? 1 : 0][state][tries].y;
    }

    public int maxTries(int piece, int state) {
        return kicks[piece == GameLogic.PIECE_I ? 1 : 0][state].length;
    }

}
